# 자료구조  
자료를 효율적으로 이용할 수 있도록 컴퓨터에 저장하는 방법  

1. 연속된 자료 구조 
모든 원소를 단일 메모리 청크에 저장하고 캐시 지역성을 가진다. O(1)  
I번째 원소 : 시작주소 + I + sizeof(type)  
동적 배열 : int* arr = new int[size];  
정적 배열 : 스택 메모리 영역에 할당되며, 함수를 벗어날 때 자동으로 해제된다.  
동적 배열 : 힙 영억에 할당되며, 사용자가 직접 해제하기 전까지 유지된다.  
  
2. 연결된 자료 구조   
‘노드’라고 하는 여러 개의 메모리 청크에 데이터를 저장하며, 서로 다른 메모리 위치에 데이터가 저장된다.   
노드는 각각의 데이터와 노드를 가리킬 포인터를 가지며, 포인터를 이용하기 때문에 원소의 삽입이나 삭제는 빠르지만 데이터 순회 및 선형 시간 복잡도는 느린 편이다. 

## Array  
- 구현이 간단하고 효율적임 / 배열의 인덱스 번호로 저장공간 접근이 가능
- 리스트의 크기가 고정되어있어 저장공간의 재 할당이 필요
- 리스트의 중간에 항목을 추가, 삭제 시 다른 항목을 옮겨야 함

원소의 타입과 배열 크기를 매개변수로 사용하는 클래스 템플릿이며, 메모리를 자동으로 할당하고 해제한다.
→ std::array<자료형,크기>변수명
- front() : 배열의 첫 번째 원소에 대한 참조 반환
- back() : 배열의 마지막 원소에 대한 참조 반환
- data() : 배열 객체 내부에서 실제 데이터 버퍼를 가리키는 포인터 반환
프로그램 실행중엔 변경할 수 없으며, 크기가 고정되어 있어 원소의 추가나 삭제가 안되고, 스택 메모리만 사용한다.



  
## Vector   
가변 크기 배열이 가능하고, 초기화 과정에 데이터의 크기를 제공하지 않아도 된다.
- push_back() : 맨 마지막에 새로운 원소를 추가하며, 매우 빠르게 동작한다.
- insert() : 삽입할 위치를 나타내는 반복자를 파라미터로 받아 원하는 위치에 원소를 추가한다.
- pop_back() : 벡터에서 맨 마지막 원소를 제거하며, 벡터 크기는 1만큼 줄어든다.
- erase() : 반복자 하나를 인자로 받아 해당 위치 원소를 제거하거나, 범위의 시작과 끝을 타나내는 반복자를 받아 시작부터 끝 바로 앞 원소를 제거한다.
- clear() : 모든 원소를 제거하여 완전히 빈 벡터로 만든다.
- reserve(capacity) : 벡터에서 사용할 용량을 지정한다.
- shrink_to_fit : 여분의 메모리 공간을 해제하는 용도로 사용된다.

## List / Linear  
- 순서가 있는 항목의 모임
- 기본 연산 : 추가, 제거, 검색 등
- 리스트를 구현하는 대표적인 방법 : 배열, 연결리스트

```c++
#include <stdio.h>
#include <list>

using namespace std;

int main()
{
	list<int> list1 = { 1,2,3,4,5 };
	list1.push_back(6);                                     // push_back(n) : 리스트 맨 뒤에 n을 삽입
	list1.insert(next(list1.begin()), 0);                   // 맨 처음 원소 다음 위치에 0 삽입
	list1.insert(list1.end(), 7);                           // 리스트명.end(),n : 리스트 맨 뒤에 n 삽입

	list1.pop_back();                                       // 맨 뒤 원소 제거
	
	for (auto i : list1) 
		printf("%d ", i);

	return 0;
}
```



## Linked List  
- 리스트의 중간에 항목을 추가, 삭제 시 다른 항목을 옮길 필요가 없음  
- 링크 필드를 위한 추가 저장 공간이 필요  
- 리스트의 중간 항목을 바로 접근하는 것이 불가능  


  
▶std::forward_list 
기본적인 연결 리스트의 성능을 유지하면서 추가적인 기능을 제공한다. 중간에 자료를 추가하거나 삭제하는 게 앞 두 가지와 다르게 효율적이다.
- push(pop)_front() : 맨 앞에 새로운 원소 삽입 및 삭제
- insert(erase)_after() : 특정 위치에 원소 삽입 및 삭제
- remove() : 삭제할 원소 값 하나를 매개변수로 받고, 조건에 일치하는 원소를 찾아 삭제한다.
- remobve_if() : boor 값 반환하는 조건자 함수를 인자로 받고 true면 삭제한다.
- sort() : 원소 데이터를 정렬한다.
- reverse() : 저장된 원소의 순서를 역순으로 변경한다.
- unique() : 리스트에서 홀로 나타나는 원소는 놔두고, 중복시 첫 번째 외 나머지를 제거한다.

▶반복자
포인터와 비슷하지만, STL 컨테이너에 대해 공통의 인터페이스를 제공한다. 
▸접근 반복자 : 특정 위치의 원소에 곧바로 접근할 수 있다. ex) 벡터, 배열
▸순방향 반복자 : 역방향 이동 기능이 없어, 바로 이전 노드로 이동시 처음부터 찾아가야 하는 경우이다.
- advance() : 반복자와 거리 값을 인자로 받고, 반복자를 거리 값만큼 증가시킨다.
- next(), prev() : 반복자와 거리 값을 인자로 받고, 해당 반복자에서 지정한 거리만큼 떨어진 위치의 반복자 반환한다.

▶std::list
양쪽 방향으로 연결된 이중 연결 리스트이며 forward_list에 비해 각 노드에 처음과 마지막 두 개의 를 가져포인터 더 많은 기능을 제공한다.
std::list의 반복자는 어느 방향으로든 이동할 수 있으므로 양방향 반복자라고 부른다.
▸ 컨테이너가 변경되어 특정 노드 또는 원소의 메모리 주소가 바뀌면 사용하던 반복자가 무효화될 수 있다.

▶std:deque
덱은 양방향으로 매우 빠르게 확장할 수 있어야 하며, 모든 원소에 임의 접근을 제공해야 한다.
덱은 push_front(), push_back(), insert(), emplace_front(), emplace_back(), emplace(), pop_front(), pop_back(), erase() 등 벡터와 리스트에서 제공되는 함수를 조합한 것 이상의 기능을 제공한다.
매우 빠른 동작과 효과적인 임의 접근을 제공하는 유일한 컨테이너이다.

▶ 컨테이너 어댑터
기존 컨테이너의 인터페이스를 제한하여 만든 기능이 제한되거나 변형된 컨테이너이다.

▸std::stack
데이터 처리와 보관을 위해 LIFO의 후입선출 구조를 사용한다.
empty, size, top, push, pop, emplace 등의 함수를 제공한다.
원소 저장 공간을 재할당할 때 벡터처럼 전체 원소를 이동할 필요가 없기에 효율적이다.

▸std::queue
FIFO의 선입선출 구조를 사용하며, 스택과 비슷한 함수를 지원한다.

▸std::prioirty_queue
힙이라고 부르는 매우 유용한 구조를 제공한다.
컨테이너에서 가장 작은 원소에 빠르게 접근할 수 있는 자료구조이다.
최소나 최대 원소에 접근하는 동작은 O(1)의 시간복잡도를 가지며, 원소 삽입은 O(log n) 시간 복잡도로 동작하여, 원소 제거는 최대/최소 원소에 대해서만 가능하다.

▶벤치마킹 : 통계 데이터를 기반으로 더 나은 접근 방식을 결정하는 방법이다.

### Dynamic Programming ( 동적 계획법 )  
``중복되는 부분 문제`` 최종 해답을 찾기 위해 여러 개의 부분 문제 또는 중간 단계 문제를 풀어야 하며, 이 문제는 한 번 이상 나타난다. 

### Greedy Algorithm  
